/*
	Copyright (c) 2025, VeriSign, Inc.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted (subject to the limitations in the disclaimer
	below) provided that the following conditions are met:

		* Redistributions of source code must retain the above copyright notice,
		this list of conditions and the following disclaimer.

		* Redistributions in binary form must reproduce the above copyright
		notice, this list of conditions and the following disclaimer in the
		documentation and/or other materials provided with the distribution.

		* Neither the name of the copyright holder nor the names of its
		contributors may be used to endorse or promote products derived from this
		software without specific prior written permission.

	NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY
	THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
	CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
	PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
	CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
	IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
*/
#include <config.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>

#include "mtltest.h"
#include "mtllib.h"
#include "mtltest_full_signature.h"
#include "mtltest_signed_ladder.h"

// Prototypes for testing functions
uint8_t mtltest_mtllib_key_new(void);
uint8_t mtltest_mtllib_key_new_null(void);
uint8_t mtltest_mtllib_key_get_pubkey_bytes(void);
uint8_t mtltest_mtllib_key_pubkey_from_params(void);
uint8_t mtltest_mtllib_key_pubkey_from_params_null(void);
uint8_t mtltest_mtllib_key_from_buffer(void);
uint8_t mtltest_mtllib_key_from_buffer_null(void);
uint8_t mtltest_mtllib_key_to_buffer(void);
uint8_t mtltest_mtllib_key_to_buffer_null(void);
uint8_t mtltest_mtllib_sign_append(void);
uint8_t mtltest_mtllib_sign_append_null(void);
uint8_t mtltest_mtllib_sign_free_handle_null(void);
uint8_t mtltest_mtllib_sign_get_condensed_sig(void);
uint8_t mtltest_mtllib_sign_get_condensed_sig_null(void);
uint8_t mtltest_mtllib_sign_get_signed_ladder(void);
uint8_t mtltest_mtllib_sign_get_signed_ladder_null(void);
uint8_t mtltest_mtllib_sign_get_full_sig(void);
uint8_t mtltest_mtllib_sign_get_full_sig_null(void);

uint8_t mtltest_mtllib_verify_condensed(void);
uint8_t mtltest_mtllib_verify_condensed_no_ladder(void);
uint8_t mtltest_mtllib_verify_full(void);
uint8_t mtltest_mtllib_verify_null(void);

uint8_t mtltest_mtllib_verify_signed_ladder(void);
uint8_t mtltest_mtllib_verify_signed_ladder_no_sig(void);
uint8_t mtltest_mtllib_verify_signed_ladder_corrupt(void);
uint8_t mtltest_mtllib_verify_signed_ladder_null(void);



uint8_t mtltest_mtllib(void)
{
	NEW_TEST("MTL Library Tests");

	RUN_TEST(mtltest_mtllib_key_new,
			 "Verify MTL library key generation function");
	RUN_TEST(mtltest_mtllib_key_new_null,
			 "Verify MTL library key generation function with NULL parameters");
	RUN_TEST(mtltest_mtllib_key_get_pubkey_bytes,
			 "Verify MTL library get public key from a key set");
	RUN_TEST(mtltest_mtllib_key_pubkey_from_params,
			 "Verify MTL library get public key from a parameter set");
	RUN_TEST(mtltest_mtllib_key_pubkey_from_params_null,
			 "Verify MTL library get public key from a parameter set with NULL parameters");
	RUN_TEST(mtltest_mtllib_key_from_buffer,
			 "Verify MTL library get a key from a byte buffer");
	RUN_TEST(mtltest_mtllib_key_from_buffer_null,
			 "Verify MTL library get a key from a byte buffer with NULL parameters");
	RUN_TEST(mtltest_mtllib_key_to_buffer,
			 "Verify MTL library write a key to a byte buffer");
	RUN_TEST(mtltest_mtllib_key_to_buffer_null,
			 "Verify MTL library write a key to a byte buffer with NULL parameters");
	RUN_TEST(mtltest_mtllib_sign_append,
			 "Verify MTL library signer append message");
	RUN_TEST(mtltest_mtllib_sign_append_null,
			 "Verify MTL library signer append message with NULL parameters");
	RUN_TEST(mtltest_mtllib_sign_free_handle_null,
			 "Verify MTL library signer free message handle with NULL parameters");
	RUN_TEST(mtltest_mtllib_sign_get_condensed_sig,
			 "Verify MTL library signer get condensed signature");
	RUN_TEST(mtltest_mtllib_sign_get_condensed_sig_null,
			 "Verify MTL library signer get condensed signature with NULL parameters");
	RUN_TEST(mtltest_mtllib_sign_get_signed_ladder,
			 "Verify MTL library signer get signed ladder");
	RUN_TEST(mtltest_mtllib_sign_get_signed_ladder_null,
			 "Verify MTL library signer get signed ladder with NULL parameters");
	RUN_TEST(mtltest_mtllib_sign_get_full_sig,
			 "Verify MTL library signer get full signature");
	RUN_TEST(mtltest_mtllib_sign_get_full_sig_null,
			 "Verify MTL library signer get full signature with NULL parameters");
	RUN_TEST(mtltest_mtllib_verify_condensed,
			 "Verify MTL library verify a condensed signature");
	RUN_TEST(mtltest_mtllib_verify_condensed_no_ladder,
			 "Verify MTL library verify a condensed signature with no ladder");
	RUN_TEST(mtltest_mtllib_verify_full,
			 "Verify MTL library verify a full signature");
	RUN_TEST(mtltest_mtllib_verify_null,
			 "Verify MTL library verify a signature with NULL parameters");
	RUN_TEST(mtltest_mtllib_verify_signed_ladder,
			 "Verify MTL library verify a signed ladder");
	RUN_TEST(mtltest_mtllib_verify_signed_ladder_no_sig,
			 "Verify MTL library verify a signed ladder missing the signature");
	RUN_TEST(mtltest_mtllib_verify_signed_ladder_corrupt,
			 "Verify MTL library verify a signed ladder that is corrupt");			 			 
	RUN_TEST(mtltest_mtllib_verify_signed_ladder_null,
			 "Verify MTL library verify a signed ladder with NULL parameters");			 

	return 0;
}

extern MTL_ALGORITHM_PROPS sig_algos[];

/**
 * Test the mtl initialization routines
 */
uint8_t mtltest_mtllib_key_new(void)
{
	size_t algo = 0;
	MTLLIB_CTX *ctx = NULL;

	// Test creating key with no context string
	algo = 0;
	while (sig_algos[algo].name != NULL)
	{
		ctx = NULL;
		assert(mtllib_key_new(sig_algos[algo].name, &ctx, NULL) == MTLLIB_OK);
		assert(ctx->algo_params == &sig_algos[algo]);
		assert(ctx->signature != NULL);
		assert(ctx->secret_key != NULL);
		assert(ctx->secret_key_len >= 64);
		assert(ctx->public_key != NULL);
		assert(ctx->public_key_len >= 32);
		assert(ctx->mtl != NULL);
		assert(ctx->mtl->ctx_str == NULL);
		mtllib_key_free(ctx);
		algo++;
	}

	// Test creating key with context string
	algo = 0;
	while (sig_algos[algo].name != NULL)
	{
		ctx = NULL;
		assert(mtllib_key_new(sig_algos[algo].name, &ctx, "MTLLIB_Test_CTX") == MTLLIB_OK);
		assert(ctx->algo_params == &sig_algos[algo]);
		assert(ctx->signature != NULL);
		assert(ctx->secret_key != NULL);
		assert(ctx->secret_key_len >= 64);
		assert(ctx->public_key != NULL);
		assert(ctx->public_key_len >= 32);
		assert(ctx->mtl != NULL);
		assert(strcmp(ctx->mtl->ctx_str, "MTLLIB_Test_CTX") == 0);
		mtllib_key_free(ctx);
		algo++;
	}

	return 0;
}

/**
 * Test the mtl initialization routines with NULL parameters
 */
uint8_t mtltest_mtllib_key_new_null(void)
{
	MTLLIB_CTX *ctx = NULL;

	assert(mtllib_key_new(NULL, &ctx, NULL) == MTLLIB_NULL_PARAMS);
	assert(mtllib_key_new("SLH-DSA-MTL-SHA2-128S", NULL, NULL) == MTLLIB_NULL_PARAMS);

	return 0;
}

uint8_t mtltest_mtllib_key_get_pubkey_bytes(void)
{
	MTLLIB_CTX *ctx = NULL;
	uint8_t *public_key = NULL;

	assert(mtllib_key_new("SLH-DSA-MTL-SHA2-128S", &ctx, NULL) == MTLLIB_OK);
	assert(mtllib_key_get_pubkey_bytes(ctx, &public_key) == 32);
	assert(public_key == ctx->public_key);
	mtllib_key_free(ctx);

	return 0;
}

uint8_t mtltest_mtllib_key_get_pubkey_bytes_null(void)
{
	MTLLIB_CTX *ctx = NULL;
	uint8_t *public_key = NULL;

	assert(mtllib_key_new("SLH-DSA-MTL-SHA2-128S", &ctx, NULL) == MTLLIB_OK);
	assert(mtllib_key_get_pubkey_bytes(NULL, &public_key) == 0);
	assert(ctx == NULL);
	assert(public_key == NULL);
	assert(mtllib_key_get_pubkey_bytes(ctx, NULL) == 0);
	assert(ctx == NULL);
	assert(public_key == NULL);
	mtllib_key_free(ctx);

	return 0;
}

uint8_t mtltest_mtllib_key_pubkey_from_params(void)
{
	size_t algo = 0;
	MTLLIB_CTX *ctx = NULL;
	uint8_t pubkey[128];
	size_t pubkey_len[] = {32,32,48,48,64,64,32,32,48,48,64,64};
	uint8_t sid[8];
	size_t sid_len = 8;
	FILE *fd = NULL;

	memset(&sid[0], 0x55, 8);
	// Setup to get random data for the test pubkey
	if ((fd = fopen("/dev/random", "r")) == NULL) {
		return 1;
	}


	// Test creating key with no context string
	algo = 0;
	while (sig_algos[algo].name != NULL)
	{
		fread(pubkey, 128, 1, fd);
		ctx = NULL;
		assert(mtllib_key_pubkey_from_params(sig_algos[algo].name, &ctx, NULL, pubkey, pubkey_len[algo], sid, sid_len) == MTLLIB_OK);
		assert(ctx->algo_params == &sig_algos[algo]);
		assert(ctx->signature != NULL);
		assert(ctx->secret_key != NULL);
		assert(ctx->secret_key_len == 0);
		assert(ctx->public_key != NULL);
		assert(memcmp(ctx->public_key, pubkey, pubkey_len[algo]) == 0);
		assert(ctx->public_key_len == pubkey_len[algo]);
		assert(ctx->mtl != NULL);
		assert(ctx->mtl->ctx_str == NULL);
		mtllib_key_free(ctx);
		algo++;
	}

	// Test creating key with context string
	algo = 0;
	while (sig_algos[algo].name != NULL)
	{
		ctx = NULL;
		assert(mtllib_key_pubkey_from_params(sig_algos[algo].name, &ctx, "MTLLIB_Test_CTX", pubkey, pubkey_len[algo], sid, sid_len) == MTLLIB_OK);
		assert(ctx->algo_params == &sig_algos[algo]);
		assert(ctx->signature != NULL);
		assert(ctx->secret_key != NULL);
		assert(ctx->secret_key_len == 0);
		assert(ctx->public_key != NULL);
		assert(memcmp(ctx->public_key, pubkey, pubkey_len[algo]) == 0);
		assert(ctx->public_key_len == pubkey_len[algo]);
		assert(ctx->mtl != NULL);
		assert(strcmp(ctx->mtl->ctx_str, "MTLLIB_Test_CTX") == 0);
		mtllib_key_free(ctx);
		algo++;
	}
	fclose(fd);	

	return 0;
}

uint8_t mtltest_mtllib_key_pubkey_from_params_null(void)
{
	MTLLIB_CTX *ctx = NULL;
	uint8_t sid[8];
	uint8_t pubkey[32];

	memset(&sid[0],0x55, 8);
	memset(&pubkey[0], 0xaa, 32);

	assert(mtllib_key_pubkey_from_params(NULL, &ctx, NULL, &pubkey[0], 32, &sid[0], 8) == MTLLIB_NULL_PARAMS);
	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHA2-128S", NULL, NULL, &pubkey[0], 32, &sid[0], 8) == MTLLIB_NULL_PARAMS);
	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHA2-128S", &ctx, NULL, NULL, 32, &sid[0], 8) == MTLLIB_NULL_PARAMS);
	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHA2-128S", &ctx, NULL, &pubkey[0], 32, NULL, 8) == MTLLIB_NULL_PARAMS);

	return 0;
}

uint8_t mtltest_mtllib_key_from_buffer(void)
{
	MTLLIB_CTX *ctx = NULL;
	size_t buffer_no_ctx_size = 153;
	uint8_t buffer_no_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x79, 0x11, 0xc8,
		 0x41, 0x32, 0x11, 0x3a, 0x53, 0x86, 0x75, 0x37, 0xf4, 0x45, 0x4c, 0xf3, 0xa0, 0x40, 0x74, 0xab,
		 0x4b, 0xb4, 0x82, 0x9e, 0x85, 0x1a, 0x77, 0x3e, 0xb8, 0xc0, 0x5e, 0x2b, 0x2c, 0x5c, 0x23, 0x57,
		 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4, 0xdc, 0xfa, 0xd1, 0x78,
		 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56, 0x86, 0x00, 0x00, 0x00,
		 0x20, 0x5c, 0x23, 0x57, 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4,
		 0xdc, 0xfa, 0xd1, 0x78, 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56,
		 0x86, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x32, 0x34, 0xf0, 0xf5, 0xbe,
		 0x58, 0xc4, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
	size_t buffer_ctx_size = 165;
	uint8_t buffer_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x5c, 0xa2, 0x9c,
		 0x59, 0xbe, 0xb6, 0x5a, 0x53, 0x61, 0x11, 0x16, 0xd3, 0xab, 0x70, 0xe5, 0x34, 0x98, 0x29, 0x10,
		 0xa7, 0x1d, 0xe0, 0xc5, 0x11, 0x01, 0xe5, 0xec, 0xa8, 0x21, 0xf9, 0x2f, 0x26, 0xa1, 0x05, 0xf5,
		 0x54, 0x97, 0x5d, 0xfc, 0x15, 0x3c, 0x9a, 0x99, 0x63, 0x30, 0xff, 0xe4, 0xb8, 0x78, 0xff, 0x0b,
		 0x33, 0xc9, 0xa4, 0xdc, 0x03, 0x34, 0x19, 0x94, 0x34, 0x8d, 0x05, 0x23, 0x44, 0x00, 0x00, 0x00,
		 0x20, 0xa1, 0x05, 0xf5, 0x54, 0x97, 0x5d, 0xfc, 0x15, 0x3c, 0x9a, 0x99, 0x63, 0x30, 0xff, 0xe4,
		 0xb8, 0x78, 0xff, 0x0b, 0x33, 0xc9, 0xa4, 0xdc, 0x03, 0x34, 0x19, 0x94, 0x34, 0x8d, 0x05, 0x23,
		 0x44, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x4d, 0x54, 0x4c, 0x5f, 0x54, 0x45, 0x53, 0x54, 0x5f,
		 0x43, 0x54, 0x58, 0x00, 0x00, 0x00, 0x08, 0x3b, 0x78, 0x7f, 0xff, 0xb7, 0x53, 0x62, 0xb0, 0x00,
		 0x00, 0x00, 0x00, 0x00, 0x10};

	assert(mtllib_key_from_buffer(buffer_no_ctx, buffer_no_ctx_size, &ctx) == MTLLIB_OK);
	assert(ctx->algo_params == &sig_algos[6]);
	assert(ctx->signature != NULL);
	assert(ctx->secret_key != NULL);
	assert(ctx->secret_key_len == 64);
	assert(ctx->public_key != NULL);
	assert(ctx->public_key_len == 32);
	assert(ctx->mtl != NULL);
	assert(ctx->mtl->ctx_str == NULL);
	mtllib_key_free(ctx);

	assert(mtllib_key_from_buffer(buffer_ctx, buffer_ctx_size, &ctx) == MTLLIB_OK);
	assert(ctx->algo_params == &sig_algos[6]);
	assert(ctx->signature != NULL);
	assert(ctx->secret_key != NULL);
	assert(ctx->secret_key_len == 64);
	assert(ctx->public_key != NULL);
	assert(ctx->public_key_len == 32);
	assert(ctx->mtl != NULL);
	assert(strcmp(ctx->mtl->ctx_str, "MTL_TEST_CTX") == 0);
	mtllib_key_free(ctx);

	return 0;
}

uint8_t mtltest_mtllib_key_from_buffer_null(void)
{
	MTLLIB_CTX *ctx = NULL;
	size_t buffer_no_ctx_size = 153;
	uint8_t buffer_no_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x79, 0x11, 0xc8,
		 0x41, 0x32, 0x11, 0x3a, 0x53, 0x86, 0x75, 0x37, 0xf4, 0x45, 0x4c, 0xf3, 0xa0, 0x40, 0x74, 0xab,
		 0x4b, 0xb4, 0x82, 0x9e, 0x85, 0x1a, 0x77, 0x3e, 0xb8, 0xc0, 0x5e, 0x2b, 0x2c, 0x5c, 0x23, 0x57,
		 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4, 0xdc, 0xfa, 0xd1, 0x78,
		 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56, 0x86, 0x00, 0x00, 0x00,
		 0x20, 0x5c, 0x23, 0x57, 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4,
		 0xdc, 0xfa, 0xd1, 0x78, 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56,
		 0x86, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x32, 0x34, 0xf0, 0xf5, 0xbe,
		 0x58, 0xc4, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};

	assert(mtllib_key_from_buffer(NULL, buffer_no_ctx_size, &ctx) == MTLLIB_NULL_PARAMS);
	assert(mtllib_key_from_buffer(buffer_no_ctx, 0, &ctx) == MTLLIB_NULL_PARAMS);

	return 0;
}

uint8_t mtltest_mtllib_key_to_buffer(void)
{
	MTLLIB_CTX *ctx = NULL;
	size_t buffer_size = 0;
	uint8_t *buffer = NULL;
	size_t identifier_len = 26;
	uint8_t identifier[] =
		{0x00, 0x00, 0x00, 0x16, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x4b, 0x45, 0x2d, 0x31, 0x32, 0x38, 0x53};
	size_t context_str_len = 12;
	char *context_str = "MTL_TEST_CTX";

	assert(mtllib_key_new("SLH-DSA-MTL-SHAKE-128S", &ctx, NULL) == MTLLIB_OK);
	buffer_size = mtllib_key_to_buffer(ctx, &buffer);
	assert(buffer_size == 154);
	assert(buffer != NULL);
	// Idenfifier String
	assert(memcmp(buffer, &identifier[0], identifier_len) == 0);
	// SK Length
	assert(buffer[26] == 0);
	assert(buffer[27] == 0);
	assert(buffer[28] == 0);
	assert(buffer[29] == 64);
	// PK Length
	assert(buffer[94] == 0);
	assert(buffer[95] == 0);
	assert(buffer[96] == 0);
	assert(buffer[97] == 32);
	// Randomizer
	assert(buffer[130] == 0);
	assert(buffer[131] == 1);
	// Context String
	assert(buffer[132] == 0);
	assert(buffer[133] == 0);
	assert(buffer[134] == 0);
	assert(buffer[135] == 0);
	// SID
	assert(buffer[136] == 0);
	assert(buffer[137] == 0);
	assert(buffer[138] == 0);
	assert(buffer[139] == 8);
	// Leaf Count
	assert(buffer[148] == 0);
	assert(buffer[149] == 0);
	assert(buffer[150] == 0);
	assert(buffer[151] == 0);
	// Hash Size
	assert(buffer[152] == 0);
	assert(buffer[153] == 16);
	free(buffer);

	assert(mtllib_key_new("SLH-DSA-MTL-SHAKE-128S", &ctx, context_str) == MTLLIB_OK);
	buffer_size = mtllib_key_to_buffer(ctx, &buffer);
	assert(buffer_size == 166);
	assert(buffer != NULL);
	assert(buffer != NULL);
	// Idenfifier String
	assert(memcmp(buffer, &identifier[0], identifier_len) == 0);
	// SK Length
	assert(buffer[26] == 0);
	assert(buffer[27] == 0);
	assert(buffer[28] == 0);
	assert(buffer[29] == 64);
	// PK Length
	assert(buffer[94] == 0);
	assert(buffer[95] == 0);
	assert(buffer[96] == 0);
	assert(buffer[97] == 32);
	// Randomizer
	assert(buffer[130] == 0);
	assert(buffer[131] == 1);
	// Context String
	assert(buffer[132] == 0);
	assert(buffer[133] == 0);
	assert(buffer[134] == 0);
	assert(buffer[135] == context_str_len);
	assert(memcmp(&buffer[136], context_str, context_str_len) == 0);
	// SID
	assert(buffer[148] == 0);
	assert(buffer[149] == 0);
	assert(buffer[150] == 0);
	assert(buffer[151] == 8);
	// Leaf Count
	assert(buffer[160] == 0);
	assert(buffer[161] == 0);
	assert(buffer[162] == 0);
	assert(buffer[163] == 0);
	// Hash Size
	assert(buffer[164] == 0);
	assert(buffer[165] == 16);
	free(buffer);

	mtllib_key_free(ctx);
	return 0;
}

uint8_t mtltest_mtllib_key_to_buffer_null(void)
{
	MTLLIB_CTX *ctx = NULL;
	size_t buffer_size = 0;
	uint8_t *buffer = NULL;

	assert(mtllib_key_new("SLH-DSA-MTL-SHAKE-128S", &ctx, NULL) == MTLLIB_OK);
	buffer_size = mtllib_key_to_buffer(NULL, &buffer);
	assert(buffer_size == 0);
	assert(buffer == NULL);
	buffer_size = mtllib_key_to_buffer(ctx, NULL);
	assert(buffer_size == 0);
	assert(buffer == NULL);

	mtllib_key_free(ctx);
	return 0;
}

uint8_t mtltest_mtllib_sign_append(void)
{
	MTLLIB_CTX *ctx = NULL;
	MTL_HANDLE *handle;
	size_t buffer_no_ctx_size = 153;
	uint8_t sid_val[] = {0x32, 0x34, 0xf0, 0xf5, 0xbe, 0x58, 0xc4, 0xc6};
	uint8_t msg[] = "Test Message";
	size_t msg_len = 13;
	size_t index = 0;
	uint8_t buffer_no_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x79, 0x11, 0xc8,
		 0x41, 0x32, 0x11, 0x3a, 0x53, 0x86, 0x75, 0x37, 0xf4, 0x45, 0x4c, 0xf3, 0xa0, 0x40, 0x74, 0xab,
		 0x4b, 0xb4, 0x82, 0x9e, 0x85, 0x1a, 0x77, 0x3e, 0xb8, 0xc0, 0x5e, 0x2b, 0x2c, 0x5c, 0x23, 0x57,
		 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4, 0xdc, 0xfa, 0xd1, 0x78,
		 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56, 0x86, 0x00, 0x00, 0x00,
		 0x20, 0x5c, 0x23, 0x57, 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4,
		 0xdc, 0xfa, 0xd1, 0x78, 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56,
		 0x86, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x32, 0x34, 0xf0, 0xf5, 0xbe,
		 0x58, 0xc4, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};

	assert(mtllib_key_from_buffer(buffer_no_ctx, buffer_no_ctx_size, &ctx) == MTLLIB_OK);
	assert(ctx->algo_params == &sig_algos[6]);
	assert(ctx->signature != NULL);
	assert(ctx->secret_key != NULL);
	assert(ctx->secret_key_len == 64);
	assert(ctx->public_key != NULL);
	assert(ctx->public_key_len == 32);
	assert(ctx->mtl != NULL);
	assert(ctx->mtl->ctx_str == NULL);

	for (index = 0; index < 15; index++)
	{
		assert(mtllib_sign_append(ctx, msg, msg_len, &handle) == MTLLIB_OK);
		assert(&handle != NULL);
		assert(handle->leaf_index == index);
		assert(handle->sid_len == 8);
		assert(memcmp(handle->sid, &sid_val[0], 8) == 0);
		mtllib_sign_free_handle(&handle);
		assert(handle == NULL);
	}

	mtllib_key_free(ctx);
	return 0;
}
uint8_t mtltest_mtllib_sign_append_null(void)
{
	MTLLIB_CTX *ctx = NULL;
	MTL_HANDLE *handle;
	size_t buffer_no_ctx_size = 153;
	uint8_t msg[] = "Test Message";
	size_t msg_len = 13;
	uint8_t buffer_no_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x79, 0x11, 0xc8,
		 0x41, 0x32, 0x11, 0x3a, 0x53, 0x86, 0x75, 0x37, 0xf4, 0x45, 0x4c, 0xf3, 0xa0, 0x40, 0x74, 0xab,
		 0x4b, 0xb4, 0x82, 0x9e, 0x85, 0x1a, 0x77, 0x3e, 0xb8, 0xc0, 0x5e, 0x2b, 0x2c, 0x5c, 0x23, 0x57,
		 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4, 0xdc, 0xfa, 0xd1, 0x78,
		 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56, 0x86, 0x00, 0x00, 0x00,
		 0x20, 0x5c, 0x23, 0x57, 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4,
		 0xdc, 0xfa, 0xd1, 0x78, 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56,
		 0x86, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x32, 0x34, 0xf0, 0xf5, 0xbe,
		 0x58, 0xc4, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};

	assert(mtllib_key_from_buffer(buffer_no_ctx, buffer_no_ctx_size, &ctx) == MTLLIB_OK);
	assert(ctx->algo_params == &sig_algos[6]);
	assert(ctx->signature != NULL);
	assert(ctx->secret_key != NULL);
	assert(ctx->secret_key_len == 64);
	assert(ctx->public_key != NULL);
	assert(ctx->public_key_len == 32);
	assert(ctx->mtl != NULL);
	assert(ctx->mtl->ctx_str == NULL);

	assert(mtllib_sign_append(NULL, msg, msg_len, &handle) == MTLLIB_NULL_PARAMS);
	assert(handle == NULL);
	mtllib_sign_free_handle(&handle);
	assert(handle == NULL);
	assert(mtllib_sign_append(ctx, NULL, msg_len, &handle) == MTLLIB_NULL_PARAMS);
	assert(mtllib_sign_append(ctx, msg, msg_len, NULL) == MTLLIB_NULL_PARAMS);

	mtllib_key_free(ctx);
	return 0;
}

uint8_t mtltest_mtllib_sign_free_handle_null(void)
{
	// Run free on NULL to make sure this doesn't crash
	mtllib_sign_free_handle(NULL);

	return 0;
}
uint8_t mtltest_mtllib_sign_get_condensed_sig(void)
{
	MTLLIB_CTX *ctx = NULL;
	MTL_HANDLE *handle = NULL;
	size_t buffer_no_ctx_size = 153;
	uint8_t sid_val[] = {0x32, 0x34, 0xf0, 0xf5, 0xbe, 0x58, 0xc4, 0xc6};
	uint8_t msg[] = "Test Message";
	size_t msg_len = 13;
	size_t index = 0;
	uint8_t *sig;
	size_t siglen;
	size_t hashes[] = {4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 2, 2, 1};
	uint8_t buffer_no_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x79, 0x11, 0xc8,
		 0x41, 0x32, 0x11, 0x3a, 0x53, 0x86, 0x75, 0x37, 0xf4, 0x45, 0x4c, 0xf3, 0xa0, 0x40, 0x74, 0xab,
		 0x4b, 0xb4, 0x82, 0x9e, 0x85, 0x1a, 0x77, 0x3e, 0xb8, 0xc0, 0x5e, 0x2b, 0x2c, 0x5c, 0x23, 0x57,
		 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4, 0xdc, 0xfa, 0xd1, 0x78,
		 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56, 0x86, 0x00, 0x00, 0x00,
		 0x20, 0x5c, 0x23, 0x57, 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4,
		 0xdc, 0xfa, 0xd1, 0x78, 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56,
		 0x86, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x32, 0x34, 0xf0, 0xf5, 0xbe,
		 0x58, 0xc4, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};

	assert(mtllib_key_from_buffer(buffer_no_ctx, buffer_no_ctx_size, &ctx) == MTLLIB_OK);
	assert(ctx->algo_params == &sig_algos[6]);
	assert(ctx->signature != NULL);
	assert(ctx->secret_key != NULL);
	assert(ctx->secret_key_len == 64);
	assert(ctx->public_key != NULL);
	assert(ctx->public_key_len == 32);
	assert(ctx->mtl != NULL);
	assert(ctx->mtl->ctx_str == NULL);

	for (index = 0; index < 15; index++)
	{
		if (handle != NULL)
		{
			mtllib_sign_free_handle(&handle);
			assert(handle == NULL);
		}
		assert(mtllib_sign_append(ctx, msg, msg_len, &handle) == MTLLIB_OK);
		assert(&handle != NULL);
		assert(handle->leaf_index == index);
		assert(handle->sid_len == 8);
		assert(memcmp(handle->sid, &sid_val[0], 8) == 0);
	}

	for (index = 0; index < 15; index++)
	{
		handle->leaf_index = index;
		assert(mtllib_sign_get_condensed_sig(ctx, handle, &sig, &siglen) == MTLLIB_OK);
		assert(siglen == 24 + (hashes[index] * 16));
		free(sig);
	}

	mtllib_sign_free_handle(&handle);
	mtllib_key_free(ctx);
	return 0;
}
uint8_t mtltest_mtllib_sign_get_condensed_sig_null(void)
{
	MTLLIB_CTX *ctx = NULL;
	MTL_HANDLE *handle = NULL;
	size_t buffer_no_ctx_size = 153;
	uint8_t sid_val[] = {0x32, 0x34, 0xf0, 0xf5, 0xbe, 0x58, 0xc4, 0xc6};
	uint8_t msg[] = "Test Message";
	size_t msg_len = 13;
	size_t index = 0;
	uint8_t *sig;
	size_t siglen;
	uint8_t buffer_no_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x79, 0x11, 0xc8,
		 0x41, 0x32, 0x11, 0x3a, 0x53, 0x86, 0x75, 0x37, 0xf4, 0x45, 0x4c, 0xf3, 0xa0, 0x40, 0x74, 0xab,
		 0x4b, 0xb4, 0x82, 0x9e, 0x85, 0x1a, 0x77, 0x3e, 0xb8, 0xc0, 0x5e, 0x2b, 0x2c, 0x5c, 0x23, 0x57,
		 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4, 0xdc, 0xfa, 0xd1, 0x78,
		 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56, 0x86, 0x00, 0x00, 0x00,
		 0x20, 0x5c, 0x23, 0x57, 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4,
		 0xdc, 0xfa, 0xd1, 0x78, 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56,
		 0x86, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x32, 0x34, 0xf0, 0xf5, 0xbe,
		 0x58, 0xc4, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};

	assert(mtllib_key_from_buffer(buffer_no_ctx, buffer_no_ctx_size, &ctx) == MTLLIB_OK);
	assert(ctx->algo_params == &sig_algos[6]);
	assert(ctx->signature != NULL);
	assert(ctx->secret_key != NULL);
	assert(ctx->secret_key_len == 64);
	assert(ctx->public_key != NULL);
	assert(ctx->public_key_len == 32);
	assert(ctx->mtl != NULL);
	assert(ctx->mtl->ctx_str == NULL);

	assert(mtllib_sign_append(ctx, msg, msg_len, &handle) == MTLLIB_OK);
	assert(&handle != NULL);
	assert(handle->leaf_index == index);
	assert(handle->sid_len == 8);
	assert(memcmp(handle->sid, &sid_val[0], 8) == 0);

	assert(mtllib_sign_get_condensed_sig(NULL, handle, &sig, &siglen) == MTLLIB_NULL_PARAMS);
	assert(siglen == 0);
	assert(mtllib_sign_get_condensed_sig(ctx, NULL, &sig, &siglen) == MTLLIB_NULL_PARAMS);
	assert(siglen == 0);
	assert(mtllib_sign_get_condensed_sig(ctx, handle, NULL, &siglen) == MTLLIB_NULL_PARAMS);
	assert(siglen == 0);
	assert(mtllib_sign_get_condensed_sig(ctx, handle, &sig, NULL) == MTLLIB_NULL_PARAMS);
	assert(siglen == 0);

	mtllib_sign_free_handle(&handle);
	mtllib_key_free(ctx);
	return 0;
}
uint8_t mtltest_mtllib_sign_get_signed_ladder(void)
{
	MTLLIB_CTX *ctx = NULL;
	MTL_HANDLE *handle = NULL;
	size_t buffer_no_ctx_size = 153;
	uint8_t sid_val[] = {0x32, 0x34, 0xf0, 0xf5, 0xbe, 0x58, 0xc4, 0xc6};
	uint8_t msg[] = "Test Message";
	size_t msg_len = 13;
	size_t index = 0;
	uint8_t *ladder;
	size_t ladder_len;
	uint8_t buffer_no_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x79, 0x11, 0xc8,
		 0x41, 0x32, 0x11, 0x3a, 0x53, 0x86, 0x75, 0x37, 0xf4, 0x45, 0x4c, 0xf3, 0xa0, 0x40, 0x74, 0xab,
		 0x4b, 0xb4, 0x82, 0x9e, 0x85, 0x1a, 0x77, 0x3e, 0xb8, 0xc0, 0x5e, 0x2b, 0x2c, 0x5c, 0x23, 0x57,
		 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4, 0xdc, 0xfa, 0xd1, 0x78,
		 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56, 0x86, 0x00, 0x00, 0x00,
		 0x20, 0x5c, 0x23, 0x57, 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4,
		 0xdc, 0xfa, 0xd1, 0x78, 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56,
		 0x86, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x32, 0x34, 0xf0, 0xf5, 0xbe,
		 0x58, 0xc4, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};

	assert(mtllib_key_from_buffer(buffer_no_ctx, buffer_no_ctx_size, &ctx) == MTLLIB_OK);
	assert(ctx->algo_params == &sig_algos[6]);
	assert(ctx->signature != NULL);
	assert(ctx->secret_key != NULL);
	assert(ctx->secret_key_len == 64);
	assert(ctx->public_key != NULL);
	assert(ctx->public_key_len == 32);
	assert(ctx->mtl != NULL);
	assert(ctx->mtl->ctx_str == NULL);

	for (index = 0; index < 15; index++)
	{
		if (handle != NULL)
		{
			mtllib_sign_free_handle(&handle);
			assert(handle == NULL);
		}
		assert(mtllib_sign_append(ctx, msg, msg_len, &handle) == MTLLIB_OK);
		assert(&handle != NULL);
		assert(handle->leaf_index == index);
		assert(handle->sid_len == 8);
		assert(memcmp(handle->sid, &sid_val[0], 8) == 0);
	}
	mtllib_sign_free_handle(&handle);

	// 4 Rungs
	assert(mtllib_sign_get_signed_ladder(ctx, &ladder, &ladder_len) == MTLLIB_OK);
	// Signed ladder should be 12 byte header 4 rungs of 24 bytes 4 bytes signature length and signatures
	assert(ladder_len == 12 + (4 * 24) + 4 + 7856); 

	free(ladder);
	mtllib_key_free(ctx);
	return 0;
}
uint8_t mtltest_mtllib_sign_get_signed_ladder_null(void)
{
	MTLLIB_CTX *ctx = NULL;
	MTL_HANDLE *handle = NULL;
	size_t buffer_no_ctx_size = 153;
	uint8_t sid_val[] = {0x32, 0x34, 0xf0, 0xf5, 0xbe, 0x58, 0xc4, 0xc6};
	uint8_t msg[] = "Test Message";
	size_t msg_len = 13;
	size_t index = 0;
	uint8_t *ladder;
	size_t ladder_len;
	uint8_t buffer_no_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x79, 0x11, 0xc8,
		 0x41, 0x32, 0x11, 0x3a, 0x53, 0x86, 0x75, 0x37, 0xf4, 0x45, 0x4c, 0xf3, 0xa0, 0x40, 0x74, 0xab,
		 0x4b, 0xb4, 0x82, 0x9e, 0x85, 0x1a, 0x77, 0x3e, 0xb8, 0xc0, 0x5e, 0x2b, 0x2c, 0x5c, 0x23, 0x57,
		 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4, 0xdc, 0xfa, 0xd1, 0x78,
		 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56, 0x86, 0x00, 0x00, 0x00,
		 0x20, 0x5c, 0x23, 0x57, 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4,
		 0xdc, 0xfa, 0xd1, 0x78, 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56,
		 0x86, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x32, 0x34, 0xf0, 0xf5, 0xbe,
		 0x58, 0xc4, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};

	assert(mtllib_key_from_buffer(buffer_no_ctx, buffer_no_ctx_size, &ctx) == MTLLIB_OK);
	assert(ctx->algo_params == &sig_algos[6]);
	assert(ctx->signature != NULL);
	assert(ctx->secret_key != NULL);
	assert(ctx->secret_key_len == 64);
	assert(ctx->public_key != NULL);
	assert(ctx->public_key_len == 32);
	assert(ctx->mtl != NULL);
	assert(ctx->mtl->ctx_str == NULL);

	for (index = 0; index < 15; index++)
	{
		if (handle != NULL)
		{
			mtllib_sign_free_handle(&handle);
			assert(handle == NULL);
		}
		assert(mtllib_sign_append(ctx, msg, msg_len, &handle) == MTLLIB_OK);
		assert(&handle != NULL);
		assert(handle->leaf_index == index);
		assert(handle->sid_len == 8);
		assert(memcmp(handle->sid, &sid_val[0], 8) == 0);
	}
	mtllib_sign_free_handle(&handle);

	assert(mtllib_sign_get_signed_ladder(NULL, &ladder, &ladder_len) == MTLLIB_NULL_PARAMS);
	assert(ladder_len == 0); 
	assert(mtllib_sign_get_signed_ladder(ctx, NULL, &ladder_len) == MTLLIB_NULL_PARAMS);
	assert(ladder_len == 0); 
	assert(mtllib_sign_get_signed_ladder(ctx, &ladder, NULL) == MTLLIB_NULL_PARAMS);
	assert(ladder_len == 0); 

	mtllib_key_free(ctx);
	return 0;
}
uint8_t mtltest_mtllib_sign_get_full_sig(void)
{
	MTLLIB_CTX *ctx = NULL;
	MTL_HANDLE *handle = NULL;
	size_t buffer_no_ctx_size = 153;
	uint8_t sid_val[] = {0x32, 0x34, 0xf0, 0xf5, 0xbe, 0x58, 0xc4, 0xc6};
	uint8_t msg[] = "Test Message";
	size_t msg_len = 13;
	size_t index = 0;
	uint8_t *sig;
	size_t siglen;
	uint8_t buffer_no_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x79, 0x11, 0xc8,
		 0x41, 0x32, 0x11, 0x3a, 0x53, 0x86, 0x75, 0x37, 0xf4, 0x45, 0x4c, 0xf3, 0xa0, 0x40, 0x74, 0xab,
		 0x4b, 0xb4, 0x82, 0x9e, 0x85, 0x1a, 0x77, 0x3e, 0xb8, 0xc0, 0x5e, 0x2b, 0x2c, 0x5c, 0x23, 0x57,
		 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4, 0xdc, 0xfa, 0xd1, 0x78,
		 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56, 0x86, 0x00, 0x00, 0x00,
		 0x20, 0x5c, 0x23, 0x57, 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4,
		 0xdc, 0xfa, 0xd1, 0x78, 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56,
		 0x86, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x32, 0x34, 0xf0, 0xf5, 0xbe,
		 0x58, 0xc4, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};

	assert(mtllib_key_from_buffer(buffer_no_ctx, buffer_no_ctx_size, &ctx) == MTLLIB_OK);
	assert(ctx->algo_params == &sig_algos[6]);
	assert(ctx->signature != NULL);
	assert(ctx->secret_key != NULL);
	assert(ctx->secret_key_len == 64);
	assert(ctx->public_key != NULL);
	assert(ctx->public_key_len == 32);
	assert(ctx->mtl != NULL);
	assert(ctx->mtl->ctx_str == NULL);

	for (index = 0; index < 15; index++)
	{
		if (handle != NULL)
		{
			mtllib_sign_free_handle(&handle);
			assert(handle == NULL);
		}
		assert(mtllib_sign_append(ctx, msg, msg_len, &handle) == MTLLIB_OK);
		assert(&handle != NULL);
		assert(handle->leaf_index == index);
		assert(handle->sid_len == 8);
		assert(memcmp(handle->sid, &sid_val[0], 8) == 0);
	}

	handle->leaf_index = 5;
	assert(mtllib_sign_get_full_sig(ctx, handle, &sig, &siglen) == MTLLIB_OK);
	// Condensed signature should 24 bytes plus num hashes * 16
	// Signed ladder should be 12 byte header 4 rungs of 24 bytes 4 bytes signature length and signatures
	assert(siglen == (24 + (4 * 16)) + (12 + (4 * 24) + 4 + 7856)); 

	mtllib_sign_free_handle(&handle);
	mtllib_key_free(ctx);
	return 0;
}
uint8_t mtltest_mtllib_sign_get_full_sig_null(void)
{
	MTLLIB_CTX *ctx = NULL;
	MTL_HANDLE *handle = NULL;
	size_t buffer_no_ctx_size = 153;
	uint8_t sid_val[] = {0x32, 0x34, 0xf0, 0xf5, 0xbe, 0x58, 0xc4, 0xc6};
	uint8_t msg[] = "Test Message";
	size_t msg_len = 13;
	size_t index = 0;
	uint8_t *sig;
	size_t siglen;
	uint8_t buffer_no_ctx[] =
		{0x00, 0x00, 0x00, 0x15, 0x53, 0x4c, 0x48, 0x2d, 0x44, 0x53, 0x41, 0x2d, 0x4d, 0x54, 0x4c, 0x2d,
		 0x53, 0x48, 0x41, 0x32, 0x2d, 0x31, 0x32, 0x38, 0x53, 0x00, 0x00, 0x00, 0x40, 0x79, 0x11, 0xc8,
		 0x41, 0x32, 0x11, 0x3a, 0x53, 0x86, 0x75, 0x37, 0xf4, 0x45, 0x4c, 0xf3, 0xa0, 0x40, 0x74, 0xab,
		 0x4b, 0xb4, 0x82, 0x9e, 0x85, 0x1a, 0x77, 0x3e, 0xb8, 0xc0, 0x5e, 0x2b, 0x2c, 0x5c, 0x23, 0x57,
		 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4, 0xdc, 0xfa, 0xd1, 0x78,
		 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56, 0x86, 0x00, 0x00, 0x00,
		 0x20, 0x5c, 0x23, 0x57, 0x30, 0x9a, 0x37, 0x07, 0xd1, 0x08, 0xfe, 0x5c, 0x31, 0xe5, 0xdc, 0xb4,
		 0xdc, 0xfa, 0xd1, 0x78, 0xfc, 0xaa, 0x51, 0x16, 0xb6, 0x69, 0xb8, 0xb2, 0x63, 0x23, 0xd5, 0x56,
		 0x86, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x32, 0x34, 0xf0, 0xf5, 0xbe,
		 0x58, 0xc4, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};

	assert(mtllib_key_from_buffer(buffer_no_ctx, buffer_no_ctx_size, &ctx) == MTLLIB_OK);
	assert(ctx->algo_params == &sig_algos[6]);
	assert(ctx->signature != NULL);
	assert(ctx->secret_key != NULL);
	assert(ctx->secret_key_len == 64);
	assert(ctx->public_key != NULL);
	assert(ctx->public_key_len == 32);
	assert(ctx->mtl != NULL);
	assert(ctx->mtl->ctx_str == NULL);

	for (index = 0; index < 15; index++)
	{
		if (handle != NULL)
		{
			mtllib_sign_free_handle(&handle);
			assert(handle == NULL);
		}
		assert(mtllib_sign_append(ctx, msg, msg_len, &handle) == MTLLIB_OK);
		assert(&handle != NULL);
		assert(handle->leaf_index == index);
		assert(handle->sid_len == 8);
		assert(memcmp(handle->sid, &sid_val[0], 8) == 0);
	}

	handle->leaf_index = 5;
	assert(mtllib_sign_get_full_sig(NULL, handle, &sig, &siglen) == MTLLIB_NULL_PARAMS);
	assert(siglen == 0);
	assert(mtllib_sign_get_full_sig(ctx, NULL, &sig, &siglen) == MTLLIB_NULL_PARAMS);
	assert(siglen == 0);
	assert(mtllib_sign_get_full_sig(ctx, handle, NULL, &siglen) == MTLLIB_NULL_PARAMS);
	assert(siglen == 0);
	assert(mtllib_sign_get_full_sig(ctx, handle, &sig, NULL) == MTLLIB_NULL_PARAMS);
	assert(siglen == 0);

	mtllib_sign_free_handle(&handle);
	mtllib_key_free(ctx);
	return 0;
}

uint8_t mtltest_mtllib_verify_condensed(void) {
	MTLLIB_CTX *ctx = NULL;
	size_t sid_len = 8;
	size_t pubkey_len = 32;
	size_t msg_len = 10;
	size_t authpath_len = 88;
	size_t ladder_len = 60;
	size_t condensed_len = 0;

	uint8_t sid[] = {0xc8,0x16,0x74,0x20,0x6e,0x20,0x0f,0x1f};
	uint8_t pubkey[] = {
		0x16,0xcf,0x45,0x42,0x09,0x53,0xe2,0x41,0xbd,0x0b,0x20,0xac,0x2f,0xa5,0xe4,0xbe,0x93,0x10,0xb0,0xec,0xaa,0x98,0x7e,0x6e,0xc2,0x80,0xbb,0xb7,0xc4,0xea,0xa3,0xfa};
	uint8_t msg[] = {0x45,0xc9,0xd2,0x7a,0xc1,0x7f,0xe9,0x6c,0xef,0x29};
	uint8_t unsigned_ladder[] = {
		0x00,0x00,0xc8,0x16,0x74,0x20,0x6e,0x20,0x0f,0x1f,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x7b,0xb9,0x79,0x82,0x25,0x8b,0x52,0xac,0x9c,0x28,0x58,0x8f,
		0xfe,0x5b,0xe4,0x03,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x09,0x13,0x02,0x53,0x2b,0xc5,0x4c,0x1b,0x8e,0xe3,0x4b,0x4a,0xbe,0xfd,0xb3,0xa4,0x28};
	uint8_t authpath[] = {
		0x21,0x7d,0x59,0xd0,0x48,0xab,0x5d,0xa4,0x39,0x17,0xf8,0xf2,0xe9,0x60,0xd2,0x5f,0x00,0x00,0xc8,0x16,0x74,0x20,0x6e,0x20,0x0f,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x03,0x01,0xf8,0x51,0x87,0x18,0xd9,0xff,0x2a,0x73,0x87,0x60,0x73,0x96,0xf7,0x96,0x50,0x81,0x18,0x47,0x6d,0xe0,0xaa,0xbf,0x66,
		0x83,0xa6,0x93,0x9a,0x13,0x15,0x5a,0xaa,0xf7,0x0d,0x63,0x98,0x8d,0x10,0x97,0xc8,0x50,0x71,0x9a,0x92,0x87,0x40,0xc9,0x2b};


	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHA2-128S", &ctx, NULL, pubkey, pubkey_len, sid, sid_len) == MTLLIB_OK);
		
	assert(mtllib_verify(ctx, msg, msg_len, authpath, authpath_len, unsigned_ladder, ladder_len, &condensed_len) == MTLLIB_OK);
	assert(condensed_len == 88);
	assert(mtllib_verify(ctx, msg, msg_len, authpath, authpath_len, unsigned_ladder, ladder_len, NULL) == MTLLIB_OK);

	return 0;
}

uint8_t mtltest_mtllib_verify_condensed_no_ladder(void) {
	MTLLIB_CTX *ctx = NULL;
	uint8_t pubkey[] = {0x99,0xe3,0xfe,0x4d,0x91,0xf6,0xbc,0xd4,
						0xa7,0x09,0x1c,0xb0,0x7a,0x1c,0x4e,0xa4,
						0xa8,0xf8,0x4a,0x08,0x2e,0x61,0xe3,0xb2,
						0xf2,0x75,0x9a,0x33,0xf8,0xf3,0xe8,0xcf};
	uint8_t sid[] = {0xd7,0xa0,0x4d,0x7e,0x55,0x2a,0x23,0x3c};
	size_t sid_len = 8;
	size_t authpath_len = 56;
	uint8_t authpath[] = {
		                0x22,0x2d,0xd5,0x0a,0x78,0xf4,0xbd,0xad,
						0x96,0xce,0x5e,0x48,0xd8,0xb0,0x31,0xef,
						0x00,0x00,0xd7,0xa0,0x4d,0x7e,0x55,0x2a,
						0x23,0x3c,0x00,0x00,0x00,0x09,0x00,0x00,
						0x00,0x08,0x00,0x00,0x00,0x09,0x00,0x01,
						0x32,0x3a,0xd3,0x04,0xa5,0x21,0x37,0x21,
						0x98,0xcf,0x49,0x73,0x92,0x98,0x4f,0x51};
	size_t msg_len = 10;
	uint8_t msg[] = {0xb4,0x5b,0xc0,0x68,0xc9,0xfb,0x7c,0x2a,0x49,0xd8};
	size_t condensed_len = 0;

	memset(&sid[0], 0x55, 8);
	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHAKE-128F", &ctx, NULL, pubkey, 32, sid, sid_len) == MTLLIB_OK);
		
	assert(mtllib_verify(ctx, msg, msg_len, authpath, authpath_len, NULL, 0, NULL) == MTLLIB_NO_LADDER);
	assert(mtllib_verify(ctx, msg, msg_len, authpath, authpath_len, NULL, 0, &condensed_len) == MTLLIB_NO_LADDER);
	assert(condensed_len == 56);

	return 0;
}

uint8_t mtltest_mtllib_verify_full(void) {
	MTLLIB_CTX *ctx = NULL;
	size_t sid_len = 8;
	size_t pubkey_len = 32;
	size_t msg_len = 10;
	size_t full_signature_len = MTL_TEST_FULL_SIGNATURE_SLH_DSA_MTL_SHAKE_128S_LEN;
	size_t condensed_len = 0;


	uint8_t sid[] = {0x47,0x2a,0xf5,0xd9,0xb1,0x31,0xa6,0x8d};
	uint8_t pubkey[] = {
		0x97,0x76,0x59,0x93,0xf9,0xf5,0x1a,0xbc,0xcc,0xa2,0xae,0xde,0xe0,0x83,0xb7,0x86,0x92,0xf2,0xd1,0x01,0xcf,0xc1,0xff,0xd5,0xfc,0xe6,0xb1,0x26,0xf9,0x04,0xe7,0x36};
	uint8_t msg[] = {0x28,0x12,0x80,0x0f,0xe0,0xea,0xc4,0xe6,0x0c,0xe4};
	uint8_t full_signature[] = MTL_TEST_FULL_SIGNATURE_SLH_DSA_MTL_SHAKE_128S_BYTES;

	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHAKE-128S", &ctx, NULL, pubkey, pubkey_len, sid, sid_len) == MTLLIB_OK);
		
	assert(mtllib_verify(ctx, msg, msg_len, full_signature, full_signature_len, NULL, 0, NULL) == MTLLIB_OK);
	assert(mtllib_verify(ctx, msg, msg_len, full_signature, full_signature_len, NULL, 0, &condensed_len) == MTLLIB_OK);
	assert(condensed_len == 88);

	return 0;
}

uint8_t mtltest_mtllib_verify_null(void) {
	uint8_t unsigned_ladder[] = {
		0x00,0x00,0xd7,0xa0,0x4d,0x7e,0x55,0x2a,0x23,0x3c,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x32,0xa1,0x6f,0x14,0xaa,0xe8,0x2c,0x5b,0xd6,0x33,0xf5,0xc2,
		0x29,0xf9,0xf8,0xb3,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x09,0x5f,0x0a,0xe9,0x8b,0xca,0x0f,0x0d,0x23,0xc1,0xf8,0x70,0x7b,0x43,0xd2,0x09,0xc9};
	MTLLIB_CTX *ctx = NULL;
	uint8_t pubkey[] = {0x99,0xe3,0xfe,0x4d,0x91,0xf6,0xbc,0xd4,
						0xa7,0x09,0x1c,0xb0,0x7a,0x1c,0x4e,0xa4,
						0xa8,0xf8,0x4a,0x08,0x2e,0x61,0xe3,0xb2,
						0xf2,0x75,0x9a,0x33,0xf8,0xf3,0xe8,0xcf};
	uint8_t sid[] = {0xd7,0xa0,0x4d,0x7e,0x55,0x2a,0x23,0x3c};
	size_t sid_len = 8;
	size_t authpath_len = 56;
	uint8_t authpath[] = {
		                0x22,0x2d,0xd5,0x0a,0x78,0xf4,0xbd,0xad,
						0x96,0xce,0x5e,0x48,0xd8,0xb0,0x31,0xef,
						0x00,0x00,0xd7,0xa0,0x4d,0x7e,0x55,0x2a,
						0x23,0x3c,0x00,0x00,0x00,0x09,0x00,0x00,
						0x00,0x08,0x00,0x00,0x00,0x09,0x00,0x01,
						0x32,0x3a,0xd3,0x04,0xa5,0x21,0x37,0x21,
						0x98,0xcf,0x49,0x73,0x92,0x98,0x4f,0x51};
	size_t msg_len = 10;
	uint8_t msg[] = {0xb4,0x5b,0xc0,0x68,0xc9,0xfb,0x7c,0x2a,0x49,0xd8};

	memset(&sid[0], 0x55, 8);
	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHAKE-128F", &ctx, NULL, pubkey, 32, sid, sid_len) == MTLLIB_OK);

	assert(mtllib_verify(NULL, msg, msg_len, authpath, authpath_len, unsigned_ladder, 60, NULL) == MTLLIB_NULL_PARAMS);
	assert(mtllib_verify(ctx, NULL, msg_len, authpath, authpath_len, unsigned_ladder, 60, NULL) == MTLLIB_NULL_PARAMS);
	assert(mtllib_verify(ctx, msg, msg_len, NULL, authpath_len, unsigned_ladder, 60, NULL) == MTLLIB_NULL_PARAMS);

	return 0;
}

uint8_t mtltest_mtllib_verify_signed_ladder(void) {
	uint8_t signed_ladder[] = MTL_TEST_SIGNED_LADDER_SLH_DSA_MTL_SHAKE_128F_BYTES;
	MTLLIB_CTX *ctx = NULL;
	uint8_t pubkey[] = {0x9b,0x0c,0x89,0x5e,0x2e,0x88,0x03,0x49,
				        0x0d,0xe4,0x30,0x09,0x11,0xa8,0x01,0xb5,
					    0x33,0xa6,0x8a,0x91,0x7b,0xf7,0x43,0xfd,
					    0xe7,0xd7,0x40,0xff,0x5b,0xdd,0x85,0x30};
	uint8_t sid[] = {0x55,0x97,0x17,0xb8,0xbf,0x02,0x01,0x8e};
	size_t sid_len = 8;

	memset(&sid[0], 0x55, 8);
	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHAKE-128F", &ctx, NULL, pubkey, 32, sid, sid_len) == MTLLIB_OK);
	assert(mtllib_verify_signed_ladder(ctx, signed_ladder, MTL_TEST_SIGNED_LADDER_SLH_DSA_MTL_SHAKE_128F_LEN) == MTLLIB_OK);

	return 0;
}

uint8_t mtltest_mtllib_verify_signed_ladder_no_sig(void) {
	uint8_t unsigned_ladder[] = {
		0x00,0x00,0x55,0x97,0x17,0xb8,0xbf,0x02,0x01,0x8e,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x6f,0xc5,0x3d,0x3b,0x75,0x24,0xca,0x59,0xb9,0x9b,0xd0,0x8a,
		0x44,0x97,0x68,0xd0,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x09,0x8c,0xb7,0x07,0x3a,0x80,0x38,0xaf,0xcc,0xe8,0xe2,0x3a,0x12,0x6e,0x78,0x11,0xe6};
	MTLLIB_CTX *ctx = NULL;
	uint8_t pubkey[] = {0x9b,0x0c,0x89,0x5e,0x2e,0x88,0x03,0x49,
				        0x0d,0xe4,0x30,0x09,0x11,0xa8,0x01,0xb5,
					    0x33,0xa6,0x8a,0x91,0x7b,0xf7,0x43,0xfd,
					    0xe7,0xd7,0x40,0xff,0x5b,0xdd,0x85,0x30};
	uint8_t sid[] = {0x55,0x97,0x17,0xb8,0xbf,0x02,0x01,0x8e};
	size_t sid_len = 8;

	memset(&sid[0], 0x55, 8);
	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHAKE-128F", &ctx, NULL, pubkey, 32, sid, sid_len) == MTLLIB_OK);
	assert(mtllib_verify_signed_ladder(ctx, unsigned_ladder, 60) == MTLLIB_INDETERMINATE);

	return 0;
}

uint8_t mtltest_mtllib_verify_signed_ladder_corrupt(void) {
	uint8_t signed_ladder[] = {
		0x00,0x00,0x55,0x97,0x17,0xb8,0xbf,0x02,0x01,0x8e,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x6f,0xc5,0x3d,0x3b,0x75,0x24,0xca,0x59,0xb9,0x9b,0xd0,0x8a,
		0x44,0x97,0x68,0xd0,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x09,0x8c,0xb7,0x07,0x3a,0x80,0x38,0xaf,0xcc,0xe8,0xe2,0x3a,0x12,0x6e,0x78,0x11,0xe6,0x00,0x00,0x42,0xc0,
		0xb3,0xfe,0x3c,0x25,0x0f,0xd5,0x6f,0xcd,0x4a,0x3c,0xa0,0x11,0x9f,0x7e,0x73,0x5c,0x61,0xff,0x48,0xf4,0x65,0x9e,0x74,0xd8,0x7a,0xc5,0x5e,0x9f,0x56,0x03,0xc4,0xa6
	};
	MTLLIB_CTX *ctx = NULL;
	uint8_t pubkey[] = {0x9b,0x0c,0x89,0x5e,0x2e,0x88,0x03,0x49,
				        0x0d,0xe4,0x30,0x09,0x11,0xa8,0x01,0xb5,
					    0x33,0xa6,0x8a,0x91,0x7b,0xf7,0x43,0xfd,
					    0xe7,0xd7,0x40,0xff,0x5b,0xdd,0x85,0x30};
	uint8_t sid[] = {0x55,0x97,0x17,0xb8,0xbf,0x02,0x01,0x8e};
	size_t sid_len = 8;

	memset(&sid[0], 0x55, 8);
	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHAKE-128F", &ctx, NULL, pubkey, 32, sid, sid_len) == MTLLIB_OK);
	assert(mtllib_verify_signed_ladder(ctx, signed_ladder, 96) == MTLLIB_INDETERMINATE);

	return 0;
}

uint8_t mtltest_mtllib_verify_signed_ladder_null(void) {
	uint8_t unsigned_ladder[] = {
		0x00,0x00,0x55,0x97,0x17,0xb8,0xbf,0x02,0x01,0x8e,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x6f,0xc5,0x3d,0x3b,0x75,0x24,0xca,0x59,0xb9,0x9b,0xd0,0x8a,
		0x44,0x97,0x68,0xd0,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x09,0x8c,0xb7,0x07,0x3a,0x80,0x38,0xaf,0xcc,0xe8,0xe2,0x3a,0x12,0x6e,0x78,0x11,0xe6};
	MTLLIB_CTX *ctx = NULL;
	uint8_t pubkey[] = {0x9b,0x0c,0x89,0x5e,0x2e,0x88,0x03,0x49,
				        0x0d,0xe4,0x30,0x09,0x11,0xa8,0x01,0xb5,
					    0x33,0xa6,0x8a,0x91,0x7b,0xf7,0x43,0xfd,
					    0xe7,0xd7,0x40,0xff,0x5b,0xdd,0x85,0x30};
	uint8_t sid[] = {0x55,0x97,0x17,0xb8,0xbf,0x02,0x01,0x8e};
	size_t sid_len = 8;

	memset(&sid[0], 0x55, 8);
	assert(mtllib_key_pubkey_from_params("SLH-DSA-MTL-SHAKE-128F", &ctx, NULL, pubkey, 32, sid, sid_len) == MTLLIB_OK);

	assert(mtllib_verify_signed_ladder(NULL, unsigned_ladder, 60) == MTLLIB_NULL_PARAMS);
	assert(mtllib_verify_signed_ladder(ctx, NULL, 60) == MTLLIB_NULL_PARAMS);

	return 0;
}

